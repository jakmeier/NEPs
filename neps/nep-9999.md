---
NEP: 9999
Title: Eliminate TTN Gas Cost
Author: Jakob Meier <jakob@near.org>
DiscussionsTo: https://gov.near.org/t/proposal-predictable-storage-gas-costs-removing-touched-trie-node-cost/30191
Status: Draft
Type: Protocol
Created: 01-Nov-2022
---

## Summary

Simplify the current gas model formula for storage operations.

The current gas cost is:

`base_cost + byte_cost * BYTES + key_byte_cost * KEY_LENGTH + touched_trie_node_cost * TTN + cached_trie_node_cost * CACHED_TTN`.

The proposed new gas cost is:


`base_cost + byte_cost * BYTES +  key_byte_cost * KEY_LENGTH`.

## Motivation

Today, a storage operation charges gas based on the number of unique touched
trie nodes (TTN) that have not already been touched in the same chunk. This
number depends on the traffic of other users in the same chunk as well as on the
momentary shape of the trie.

For smart contract developers, this number is unpredictable and makes gas usage
testing very difficult. Testing on mainnet or recreating full state and foreign
traffic locally are two possible but undesirable workarounds.

With the TTN number removed from the equation, gas costs can be predicted
locally. All other gas costs, related to storage and otherwise, are already
predictable. TTN alone blocks gas cost predictability.

TTN based gas costs are also a burden for NEAR Protocol client implementations,
i.e. nearcore. The exact TTN number must be computed deterministically by all
clients. This prevents storage optimizations that use other strategies than
nearcore uses today.

Notably, [NEP-399](https://github.com/near/NEPs/pull/399) proposes flat storage
which does not need to traverse the trie for every storage operation. But with
the current gas cost model, it is necessary to still traverse it and update
caches accordingly to adhere with the current protocol specification. This
reverses all gains flat storage was meant to deliver.

If TTN is no longer charged, client implementations (e.g. nearcore) can optimize
storage layout freely. This will lead to increased stability and may allow
lowering gas costs in the future.

## Rationale and alternatives

This proposal solves two problems at once. Overspecified storage operations and
bad developer experience around storage gas costs.

A less invasive alternative to address the overspecification would be to approximate the touched trie nodes.
One idea was to charge for the maximum depth of trie nodes a contract has.
That does not fully address the problem and makes things even more complicated.
It was therefore dismissed in favour of this proposal.

No alternatives have been proposed so far to resolve the gas usage testing difficulties.

If we do not move forward with this proposal,
[NEP-399](https://github.com/near/NEPs/pull/399) is blocked and requires
alternative solutions for the gas cost model.

The new gas cost parameter values proposed rely on
[NEP-399](https://github.com/near/NEPs/pull/399) to a certain degree. But even
if that gets abandoned, removing TTN from the equation makes sense. The only
difference would be in the implementation details, where gas cost would be
higher. More on that in the reference implementation section.

## Specification

### Gas Cost Formula Without TTN

There are four storage related host function calls. The gas formulas with
removed touched trie node (TTN) cost are: 

`storage_read`
```
storage_read_base +
storage_read_key_byte * KEY_BYTES +
storage_read_value_byte * VALUE_BYTES
```

`storage_has_key`
```
storage_has_key_base +
storage_has_key_byte * KEY_BYTES
```

`storage_write`
```
storage_write_base + 
storage_write_key_byte * KEY_BYTES +
storage_write_value_byte * NEW_VALUE_BYTES +
storage_write_evicted_byte * OLD_VALUE_BYTES
```

`storage_remove`
```
storage_remove_base +
storage_remove_key_byte * KEY_BYTES +
storage_remove_ret_value_byte* OLD_VALUE_BYTES
```

In this model, the base gas costs cover the trie lookup. The extra costs for
nodes deep down in the trie nodes must be covered by the per-key-byte
parameters.

In comparison, the previous model used the TTN count to charge for trie
traversal. The base cost was only to fetch the value after the trie lookup is
done.

### Example
_A shallow understanding of a [Patricia Merkle Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) and [how near uses it](https://nomicon.io/Architecture#trie) is expected from the reader. [Neaercore implementation details](https://near.github.io/nearcore/architecture/trie.html) are not required but can be relevant for decision making._

Bob and Boormika both have an account on the NEAR blockchain. Both want to read
a value that is stored in the subtree of their account.

Bob's account is `bob.near` and the key he accesses is `map:crows`. Boormika's
account is `boormika.near` and she reads `this-is-a-long-key` right after Bob,
within the same chunk.

The following shows a possible trie shape that contains these two keys. (For the
purpose of this drawing, characters instead of nibbles are used for the trie.)

![Trie diagram showing Bob's and Boormika's state.](./assets/nep-9999/trie-depth-vs-key-length.svg)

Bob's key `map:crows` is stored at depth 9, hence reading it will touch 10 trie
nodes including the root. The key length is 9 bytes (or characters). Let's
further assume that the stored value is 100 bytes in length.

Bob's gas cost for reading is this.

```
storage_read_base +
9 * storage_read_key_byte + 
100 * storage_read_value_byte
```

In the old model, we would also have to add TTN costs.

```
10 * touching_trie_node
```

Next, when Boormika reads her key of length 18, depth 7, and again value size 100, the gas cost is as follows.

```
storage_read_base +
18 * storage_read_key_byte + 
100 * storage_read_value_byte
```

TTN costs are a bit more complicated now.

```
4 * touching_trie_node +
4 * read_cached_trie_node
```

Thanks to Bob's request earlier, the first four trie nodes Boormika touches are
in the cache. Reading them is charged at a discount. (`read_cached_trie_node` is
currently about 8 times cheaper than `touching_trie_node`.)

Boormika is happy now but she will be unpleasantly surprised when she pays more
next time because Bob was not sending his transaction.


## Reference Implementation

No code changes are necessary. Setting these two parameters to zero already
satisfies the main premise of this NEP.

```
wasm_touching_trie_node:       16_101_955_926 ->    0
wasm_read_cached_trie_node:     2_280_000_000 ->    0
```

However, some existing parameters need to be increased in order to keep gas
costs balanced with the time a client needs to fulfill storage operations.

The reference implementation uses parameter values that are in principle
feasible today, both from a dApp developer and a nearcore developer perspective.
However, the exact numbers are an implementation detail that will likely change
over time, as hardware and client implementation become faster.

```
wasm_storage_read_base:        56_356_845_750 -> 200_000_000_000
wasm_storage_has_key_base:     54_039_896_625 -> 200_000_000_000
wasm_storage_write_base:       64_196_736_000 -> 220_000_000_000
wasm_storage_remove_base:      53_473_030_500 -> 220_000_000_000
wasm_storage_read_key_byte:    30_952_533     ->     100_000_000
wasm_storage_has_key_byte:     30_790_845     ->     100_000_000
wasm_storage_write_key_byte:   70_482_867     ->   1_000_000_000
wasm_storage_remove_key_byte:  38_220_384     ->   1_000_000_000
```

The next section summarizes the rational behind these changes.
### Increasing Existing Parameter Values

The main factors to consider are:
1. How will a changed gas cost affect current dApps on NEAR?
2. What gas costs are required to guarantee system stability.

A series of experiments have been conducted to explore the parameter space and
evaluate its impact on existing dApps. The results for how users are affected is
summaries in
[Eliminate TTN gas cost](https://docs.google.com/document/d/1QoHX0xnPg0zlBJAMyEBdryx_JMuS2RzygBJ-qgRJA0Y/).
The nearcore performance evaluation still needs to finish. (TODO: link it here)

The shortest possible summary is this.
- Base costs go to 200 Ggas to cover two disk accesses. Today's usage patterns
  are largely unaffected by this.
- Read costs per key byte can stay low enough that nobody should notice it.
- Write per key byte costs need to be increased to at least 1 Ggas. This is
  noticeable to users but should be acceptable.

TODO: Include examples for how users are affected by the change.

## Deploying the Feature

Unfortunately, nearcore is not ready yet to support such low gas costs for
writes. For now, it still has to do an expensive trie traversal for every write
before it continues smart contract execution. This will be optimized in the
not-so-distant future and then it will be able to support the cost above. In the
meantime, write costs should keep following the old model.

### Proposed Strategy
Once this proposal gets accepted, it can immediately be deployed for the read
costs. This means nearcore can start using flat storage which comes with
improved system operation stability.

In a second step, the write costs can be adopted once nearcore is ready.

Shipping the read costs first will allow to observe the system's behavior in
practice and mitigates risks involved with dramatic changes in the storage
costs.

### Alternative Strategy
The alternative would be to wait with the deployment until nearcore is ready to
support reads and writes. The downside of this approach is that flat storage
will be blocked. It could only be deployed when a handful of additional
optimizations are also implemented.

The risk associated with grouping up so many complex changes to a single release
is much harder to predict than the risk involved with an incremental release.

## Security Implications
If gas costs are set too low, undercharging attacks become possible.

Extensive experiments to evaluate this have been conducted and have lead to the
proposed numbers.

## Drawbacks

On a high level, the drawbacks are this.

1. Once we removed the TTN cost, it will be very difficult to go back.
2. Gas costs increase for some patterns.
    - Using long keys for storage becomes more expensive.
    - Using many similarly named keys in the same function call becomes more expensive.
    - Reading the same value many time in the same function call becomes more expensive.

Going back to the example from above may help to understand the second point.

In the old model, Bob with the short key ends up paying much more than Boormika.
In the new model, the TTN cost is set to zero and hence Boormika with the long
key pays more than Bob.

The transition can be awkward for users, as the gas costs change in somewhat
unexpected ways. But on the flip side, moving forward gas costs will be easier
to understand.

## Unresolved Issues
- There are a bunch of TODOs in the text to finalize the benchmarking and gas
  parameter evaluations. This is expected to finish before the NEP is marked as
  ready for review.
- The deployment strategy is to do it on two steps, where the second step
  depends on upcoming optimizations in nearcore. The final decision on this is
  expected to be made as part of the NEP review process.

## Future possibilities
- One of the main motivations for this proposal is to enable
  [NEP-399](https://github.com/near/NEPs/pull/399).
- The nearcore repository could finally provide dApp developers a complete
  solution to accurately calculate gas costs locally.
- To mitigate increased gas costs for some usage patterns, we could introduce
  per function call caches. This would allow that only the first `storage_read`
  is charged fully and following request are served from memory. However, it is
  not clear at this moment whether such optimizations should be done on the
  protocol level or in the SDK.
- Once exact trie node counting is obsolete, nearcore could use
  a different format internally while maintaining the hashes according to the
  trie only to compute the state root and Merkle proofs. A few examples for data
  layout optimizations to consider:
   - We could try to rearrange the data structure to allow for parallel lookups,
     whereas today trie traversal is sequential.
   - Nodes across layers could be collapsed to reduce the number of DB requests.
   - Each account's subtrie could be stored as a serialized hash map.
- Storage operation from different receipts on different accounts no longer need
  to be strictly ordered within a chunk. (This is necessary today to calculate
  the correct TTN gas cost.) Therefore, executing multiple receipts concurrently
  will become theoretically viable.

## Copyright
[copyright]: #copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
